/* $Id: b3soinoi.c,v 3.2 02/24/04 Hui Wan Release $  */
/*
$Log:   b3soinoi.c,v $
 * Revision 3.2 02/24/04 Hui Wan 
 * BSIMSOI3.2 release
 *
*/
static char rcsid[] = "$Id: b3soinoi.c,v 3.2 02/24/04 Hui Wan Release $";

/**************************************/

/**********
Copyright 1990 Regents of the University of California.  All rights reserved.
Author: 1998 Samuel Fung, Dennis Sinitsky and Stephen Tang
File: b3soinoi.c          98/5/01
Modified by Hui Wan 02/3/5
Modified by Hui Wan 03/07/30
**********/

#include "spice.h"
#include <stdio.h>
#include <math.h>
#include "b3soidef.h"
#include "cktdefs.h"
#include "fteconst.h"
#include "iferrmsg.h"
#include "noisedef.h"
#include "util.h"
#include "suffix.h"
#include "const.h"  /* jwan */

/*
 * B3SOInoise (mode, operation, firstModel, ckt, data, OnDens)
 *    This routine names and evaluates all of the noise sources
 *    associated with MOSFET's.  It starts with the model *firstModel and
 *    traverses all of its insts.  It then proceeds to any other models
 *    on the linked list.  The total output noise density generated by
 *    all of the MOSFET's is summed with the variable "OnDens".
 */

/*
 Channel thermal and flicker noises are calculated based on the value
 of model->B3SOItnoiMod and model->B3SOIfnoiMod
 If model->B3SOItnoiMod = 0,
    Channel thermal noise = Charge based model
 If model->B3SOItnoiMod = 1,
    Channel thermal noise = Holistic noise model
 If model->B3SOIfnoiMod = 0,
    Flicker noise         = Simple model
 If model->B3SOIfnoiMod = 1,
    Flicker noise         = Unified model
*/

extern void   NevalSrc();
extern double Nintegrate();

double
B3SOIEval1ovFNoise(vds, model, here, freq, temp)
double vds, freq, temp;
B3SOImodel *model;
B3SOIinstance *here;
{
struct b3soiSizeDependParam *pParam;
double cd, esat, DelClm, EffFreq, N0, Nl;
double T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, Ssi;

    pParam = here->pParam;
    cd = fabs(here->B3SOIcd);
    esat = 2.0 * pParam->B3SOIvsattemp / here->B3SOIueff;
/* v2.2.3 bug fix */
    if(model->B3SOIem<=0.0) DelClm = 0.0;
    else {
            T0 = ((((vds - here->B3SOIVdseff) / pParam->B3SOIlitl)
                + model->B3SOIem) / esat);
            DelClm = pParam->B3SOIlitl * log (MAX(T0, N_MINLOG));
    }

    EffFreq = pow(freq, model->B3SOIef);
    T1 = CHARGE * CHARGE * CONSTboltz * cd * temp * here->B3SOIueff;
    T2 = 1.0e10 * EffFreq * here->B3SOIAbulk * model->B3SOIcox
       * pParam->B3SOIleff * pParam->B3SOIleff;

/* v2.2.3 bug fix */
    N0 = model->B3SOIcox * here->B3SOIVgsteff / CHARGE; 
    Nl = model->B3SOIcox * here->B3SOIVgsteff
         * (1.0 - here->B3SOIAbovVgst2Vtm * here->B3SOIVdseff) / CHARGE; 


    T3 = model->B3SOIoxideTrapDensityA
       * log(MAX(((N0 + here->B3SOInstar) / (Nl + here->B3SOInstar)), N_MINLOG));
    T4 = model->B3SOIoxideTrapDensityB * (N0 - Nl);
    T5 = model->B3SOIoxideTrapDensityC * 0.5 * (N0 * N0 - Nl * Nl);

    T6 = CONSTboltz * temp * cd * cd;
    T7 = 1.0e10 * EffFreq * pParam->B3SOIleff
       * pParam->B3SOIleff * pParam->B3SOIweff;
    T8 = model->B3SOIoxideTrapDensityA + model->B3SOIoxideTrapDensityB * Nl
       + model->B3SOIoxideTrapDensityC * Nl * Nl;
    T9 = (Nl + here->B3SOInstar) * (Nl + here->B3SOInstar);

    Ssi = T1 / T2 * (T3 + T4 + T5) + T6 / T7 * DelClm * T8 / T9;

    return Ssi;
}

int
B3SOInoise (mode, operation, inModel, ckt, data, OnDens)
int mode, operation;
GENmodel *inModel;
CKTcircuit *ckt;
register Ndata *data;
double *OnDens;
{
register B3SOImodel *model = (B3SOImodel *)inModel;
register B3SOIinstance *here;
struct b3soiSizeDependParam *pParam;
char name[N_MXVLNTH];
double tempOnoise;
double tempInoise;
double noizDens[B3SOINSRCS];
double lnNdens[B3SOINSRCS];

double vgs, vds;
double N0, Nl;
double T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11;
double n, ExpArg, Ssi, Swi;

/* v3.2 */
double npart_theta, npart_beta, igsquare, esat;
/* v3.2 end */

int error, i;

    /* define the names of the noise sources */
    static char *B3SOInNames[B3SOINSRCS] =
    {   /* Note that we have to keep the order */
	".rd",              /* noise due to rd */
			    /* consistent with the index definitions */
	".rs",              /* noise due to rs */
			    /* in B3SOIdefs.h */
	".rg", 		    /* noise due to rgeltd, v3.2 */
	".id",              /* noise due to id */
	".1overf",          /* flicker (1/f) noise */
        ".fb", 		    /* noise due to floating body */
	".igs",		    /* shot noise due to IGS, v3.2 */
	".igd", 	    /* shot noise due to IGD, v3.2 */
	".igb",		    /* shot noise due to IGB, v3.2 */
	
	""                  /* total transistor noise */
    };

    for (; model != NULL; model = model->B3SOInextModel)
    {    for (here = model->B3SOIinstances; here != NULL;
	      here = here->B3SOInextInstance)
	 {    pParam = here->pParam;
	      switch (operation)
	      {  case N_OPEN:
		     /* see if we have to to produce a summary report */
		     /* if so, name all the noise generators */

		      if (((NOISEAN*)ckt->CKTcurJob)->NStpsSm != 0)
		      {   switch (mode)
			  {  case N_DENS:
			          for (i = 0; i < B3SOINSRCS; i++)
				  {    (void) sprintf(name, "onoise.%s%s",
					              here->B3SOIname,
						      B3SOInNames[i]);
                                       data->namelist = (IFuid *) trealloc(
					     (char *) data->namelist,
					     (data->numPlots + 1)
					     * sizeof(IFuid));
                                       if (!data->namelist)
					   return(E_NOMEM);
		                       (*(SPfrontEnd->IFnewUid)) (ckt,
			                  &(data->namelist[data->numPlots++]),
			                  (IFuid) NULL, name, UID_OTHER,
					  (GENERIC **) NULL);
				       /* we've added one more plot */
			          }
			          break;
		             case INT_NOIZ:
			          for (i = 0; i < B3SOINSRCS; i++)
				  {    (void) sprintf(name, "onoise_total.%s%s",
						      here->B3SOIname,
						      B3SOInNames[i]);
                                       data->namelist = (IFuid *) trealloc(
					     (char *) data->namelist,
					     (data->numPlots + 1)
					     * sizeof(IFuid));
                                       if (!data->namelist)
					   return(E_NOMEM);
		                       (*(SPfrontEnd->IFnewUid)) (ckt,
			                  &(data->namelist[data->numPlots++]),
			                  (IFuid) NULL, name, UID_OTHER,
					  (GENERIC **) NULL);
				       /* we've added one more plot */

			               (void) sprintf(name, "inoise_total.%s%s",
						      here->B3SOIname,
						      B3SOInNames[i]);
                                       data->namelist = (IFuid *) trealloc(
					     (char *) data->namelist,
					     (data->numPlots + 1)
					     * sizeof(IFuid));
                                       if (!data->namelist)
					   return(E_NOMEM);
		                       (*(SPfrontEnd->IFnewUid)) (ckt,
			                  &(data->namelist[data->numPlots++]),
			                  (IFuid) NULL, name, UID_OTHER,
					  (GENERIC **)NULL);
				       /* we've added one more plot */
			          }
			          break;
		          }
		      }
		      break;
	         case N_CALC:
		      switch (mode)
		      {  case N_DENS:
		              NevalSrc(&noizDens[B3SOIRDNOIZ],
				       &lnNdens[B3SOIRDNOIZ], ckt, THERMNOISE,
				       here->B3SOIdNodePrime, here->B3SOIdNode,
				       here->B3SOIdrainConductance);

		              NevalSrc(&noizDens[B3SOIRSNOIZ],
				       &lnNdens[B3SOIRSNOIZ], ckt, THERMNOISE,
				       here->B3SOIsNodePrime, here->B3SOIsNode,
				       here->B3SOIsourceConductance);

                              if ((here->B3SOIrgateMod == 1) ||
				  (here->B3SOIrgateMod == 2))
                              {   NevalSrc(&noizDens[B3SOIRGNOIZ],
                                       &lnNdens[B3SOIRGNOIZ], ckt, THERMNOISE,
                                       here->B3SOIgNode,
				       here->B3SOIgNodeExt,
				       here->B3SOIgrgeltd);
                              }
                              else if (here->B3SOIrgateMod == 3)
                              {   NevalSrc(&noizDens[B3SOIRGNOIZ],
                                       &lnNdens[B3SOIRGNOIZ], ckt, THERMNOISE,
                                       here->B3SOIgNodeMid,
				       here->B3SOIgNodeExt,
				       here->B3SOIgrgeltd);
                              }
                              else
                              {    noizDens[B3SOIRGNOIZ] = 0.0;
                                   lnNdens[B3SOIRGNOIZ] =
                                          log(MAX(noizDens[B3SOIRGNOIZ],
					      N_MINLOG));
                              }

                              switch( model->B3SOItnoiMod )
			      {  case 0:
			              NevalSrc(&noizDens[B3SOIIDNOIZ],
				               &lnNdens[B3SOIIDNOIZ], ckt, 
					       THERMNOISE, here->B3SOIdNodePrime,
				               here->B3SOIsNodePrime,
					       (here->B3SOIueff
					       * FABS(here->B3SOIqinv
                                               / (pParam->B3SOIleff
                                               * pParam->B3SOIleff
                                               + here->B3SOIueff*FABS
                                                 (here->B3SOIqinv)
                                               *  here->B3SOIrds)))
                                               * model->B3SOIntnoi );
				      break;

/* v2.2.3 bug fix */
			         case 1:
				      T0 = here->B3SOIgm + here->B3SOIgmbs +
					   here->B3SOIgds;
				      T0 *= T0;
				      esat = 2.0 * pParam->B3SOIvsattemp /
					     here->B3SOIueff;
				      T5 = here->B3SOIVgsteff / esat /
					   pParam->B3SOIleff;
				      T5 *= T5;
				      npart_beta = model->B3SOIrnoia * (1.0 +
						 T5 * model->B3SOItnoia * 
						 pParam->B3SOIleff);
                                      npart_theta = model->B3SOIrnoib * (1.0 +
						  T5 * model->B3SOItnoib *
						  pParam->B3SOIleff);
				      igsquare = npart_theta * npart_theta *
 						 T0 * here->B3SOIVdseff / 
						 here->B3SOIcd;
                                      T1 = npart_beta * (here->B3SOIgm
                                         + here->B3SOIgmbs) + here->B3SOIgds;
                                      T2 = T1 * T1 * here->B3SOIVdseff / 
					   here->B3SOIcd;

                                      NevalSrc(&noizDens[B3SOIIDNOIZ],
                                               &lnNdens[B3SOIIDNOIZ], ckt,
                                               THERMNOISE,
                                               here->B3SOIdNodePrime,
                                               here->B3SOIsNodePrime, 
					       (T2 - igsquare));
				      break;
			      }

		              NevalSrc(&noizDens[B3SOIFLNOIZ], (double*) NULL,
				       ckt, N_GAIN, here->B3SOIdNodePrime,
				       here->B3SOIsNodePrime, (double) 0.0);

                              switch( model->B3SOIfnoiMod )
			      {  case 0:
			              noizDens[B3SOIFLNOIZ] *= model->B3SOIkf
					    * exp(model->B3SOIaf
					    * log(MAX(FABS(here->B3SOIcd),
					    N_MINLOG)))
					    / (pow(data->freq, model->B3SOIef)
					    * pParam->B3SOIleff
				            * pParam->B3SOIleff
					    * model->B3SOIcox);
				      break;
			         case 1:
			              vgs = *(ckt->CKTstates[0] + here->B3SOIvgs);
		                      vds = *(ckt->CKTstates[0] + here->B3SOIvds);
			              if (vds < 0.0)
			              {   vds = -vds;
				          vgs = vgs + vds;
			              }

			              Ssi = B3SOIEval1ovFNoise(vds, model, here,
					    data->freq, ckt->CKTtemp);
				      
				      T10 = model->B3SOIoxideTrapDensityA
					    * CONSTboltz * ckt->CKTtemp;
		                      T11 = pParam->B3SOIweff
					    * pParam->B3SOIleff
				            * pow(data->freq, model->B3SOIef)
				            * 1.0e10 * here->B3SOInstar
					    * here->B3SOInstar ;
		                      Swi = T10 / T11 * here->B3SOIcd
				            * here->B3SOIcd;
				      T1 = Swi + Ssi;
				      if (T1 > 0.0)
                                           noizDens[B3SOIFLNOIZ] *= (Ssi
								  * Swi) / T1;
				      else
                                           noizDens[B3SOIFLNOIZ] *= 0.0;
				      break;
			      }

		              lnNdens[B3SOIFLNOIZ] =
				     log(MAX(noizDens[B3SOIFLNOIZ], N_MINLOG));

			      /* v3.2 for gate tunneling shot noise */
			      NevalSrc(&noizDens[B3SOIIGSNOIZ],
                                   &lnNdens[B3SOIIGSNOIZ], ckt, SHOTNOISE,
                                   here->B3SOIgNode, here->B3SOIsNodePrime,
                                   (here->B3SOIIgs + here->B3SOIIgcs));

			      NevalSrc(&noizDens[B3SOIIGDNOIZ],
                                   &lnNdens[B3SOIIGDNOIZ], ckt, SHOTNOISE,
                                   here->B3SOIgNode, here->B3SOIdNodePrime,
                                   (here->B3SOIIgd + here->B3SOIIgcd));

			      NevalSrc(&noizDens[B3SOIIGBNOIZ],
                                   &lnNdens[B3SOIIGBNOIZ], ckt, SHOTNOISE,
                                   here->B3SOIgNode, here->B3SOIbNode,
                                   here->B3SOIig);
			      /* v3.2 for gate tunneling shot noise end */

			      /* Low frequency excess noise due to FBE */
		              NevalSrc(&noizDens[B3SOIFBNOIZ], &lnNdens[B3SOIFBNOIZ],
				          ckt, SHOTNOISE, here->B3SOIsNodePrime,
				          here->B3SOIbNode, 
                                          2.0 * model->B3SOInoif * here->B3SOIibs);

		              noizDens[B3SOITOTNOIZ] = noizDens[B3SOIRDNOIZ]
						     + noizDens[B3SOIRSNOIZ]
						     + noizDens[B3SOIRGNOIZ]
						     + noizDens[B3SOIIDNOIZ]
						     + noizDens[B3SOIFLNOIZ]
						     + noizDens[B3SOIFBNOIZ]
						     + noizDens[B3SOIIGSNOIZ]
						     + noizDens[B3SOIIGDNOIZ]
						     + noizDens[B3SOIIGBNOIZ];
		              lnNdens[B3SOITOTNOIZ] = 
				     log(MAX(noizDens[B3SOITOTNOIZ], N_MINLOG));

		              *OnDens += noizDens[B3SOITOTNOIZ];

		              if (data->delFreq == 0.0)
			      {   /* if we haven't done any previous 
				     integration, we need to initialize our
				     "history" variables.
				    */

			          for (i = 0; i < B3SOINSRCS; i++)
				  {    here->B3SOInVar[LNLSTDENS][i] =
					     lnNdens[i];
			          }

			          /* clear out our integration variables
				     if it's the first pass
				   */
			          if (data->freq ==
				      ((NOISEAN*) ckt->CKTcurJob)->NstartFreq)
				  {   for (i = 0; i < B3SOINSRCS; i++)
				      {    here->B3SOInVar[OUTNOIZ][i] = 0.0;
				           here->B3SOInVar[INNOIZ][i] = 0.0;
			              }
			          }
		              }
			      else
			      {   /* data->delFreq != 0.0,
				     we have to integrate.
				   */
			          for (i = 0; i < B3SOINSRCS; i++)
				  {    if (i != B3SOITOTNOIZ)
				       {   tempOnoise = Nintegrate(noizDens[i],
						lnNdens[i],
				                here->B3SOInVar[LNLSTDENS][i],
						data);
				           tempInoise = Nintegrate(noizDens[i]
						* data->GainSqInv, lnNdens[i]
						+ data->lnGainInv,
				                here->B3SOInVar[LNLSTDENS][i]
						+ data->lnGainInv, data);
				           here->B3SOInVar[LNLSTDENS][i] =
						lnNdens[i];
				           data->outNoiz += tempOnoise;
				           data->inNoise += tempInoise;
				           if (((NOISEAN*)
					       ckt->CKTcurJob)->NStpsSm != 0)
					   {   here->B3SOInVar[OUTNOIZ][i]
						     += tempOnoise;
				               here->B3SOInVar[OUTNOIZ][B3SOITOTNOIZ]
						     += tempOnoise;
				               here->B3SOInVar[INNOIZ][i]
						     += tempInoise;
				               here->B3SOInVar[INNOIZ][B3SOITOTNOIZ]
						     += tempInoise;
                                           }
			               }
			          }
		              }
		              if (data->prtSummary)
			      {   for (i = 0; i < B3SOINSRCS; i++)
				  {    /* print a summary report */
			               data->outpVector[data->outNumber++]
					     = noizDens[i];
			          }
		              }
		              break;
		         case INT_NOIZ:
			      /* already calculated, just output */
		              if (((NOISEAN*)ckt->CKTcurJob)->NStpsSm != 0)
			      {   for (i = 0; i < B3SOINSRCS; i++)
				  {    data->outpVector[data->outNumber++]
					     = here->B3SOInVar[OUTNOIZ][i];
			               data->outpVector[data->outNumber++]
					     = here->B3SOInVar[INNOIZ][i];
			          }
		              }
		              break;
		      }
		      break;
	         case N_CLOSE:
		      /* do nothing, the main calling routine will close */
		      return (OK);
		      break;   /* the plots */
	      }       /* switch (operation) */
	 }    /* for here */
    }    /* for model */

    return(OK);
}




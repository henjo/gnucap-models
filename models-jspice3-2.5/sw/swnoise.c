/***************************************************************************
JSPICE3 adaptation of Spice3e2 - Copyright (c) Stephen R. Whiteley 1992
Copyright 1990 Regents of the University of California.  All rights reserved.
Authors: 1987 Gary W. Ng
         1992 Stephen R. Whiteley
****************************************************************************/

#include "spice.h"
#include <stdio.h>
#include <math.h>
#include "swdefs.h"
#include "noisedef.h"
#include "fteconst.h"
#include "iferrmsg.h"
#include "util.h"

/*
 * SWnoise (mode, operation, firstModel, ckt, data, OnDens)
 *    This routine names and evaluates all of the noise sources
 *    associated with voltage- controlled switches.  It starts with the
 *    model *firstModel and traverses all of its instances.  It then
 *    proceeds to any other models on the linked list.  The total output
 *    noise density generated by the SW's is summed in the variable
 *    "OnDens".
 */


int
SWnoise (mode, operation, genmodel, ckt, dataptr, OnDens)

int mode;
int operation;
GENmodel *genmodel;
CKTcircuit *ckt;
GENERIC *dataptr;
double *OnDens;
{
    Ndata *data = (Ndata*)dataptr;
    SWmodel *model = (SWmodel *) genmodel;
    SWinstance *inst;
    char name[N_MXVLNTH];
    double tempOutNoise;
    double tempInNoise;
    double noizDens;
    double lnNdens;
    int error;
    int current_state;


    if (operation == N_OPEN) {

        /* see if we have to to produce a summary report
         * if so, name the noise generator
         */

        if (((NOISEAN*)ckt->CKTcurJob)->NStpsSm == 0)
            return (OK);

        if (mode == N_DENS) {

            for ( ; model; model = model->SWnextModel) {

                for (inst = model->SWinstances; inst != NULL;
                        inst = inst->SWnextInstance) {

                    (void)sprintf(name,"onoise.%s",inst->SWname);

                    data->namelist = (IFuid *)
                        trealloc((char *)data->namelist,
                            (data->numPlots + 1)*sizeof(IFuid));

                    if (!data->namelist)
                        return (E_NOMEM);

                    (*(SPfrontEnd->IFnewUid))(ckt,
                        &(data->namelist[data->numPlots++]),
                        (IFuid)NULL,name,UID_OTHER,(GENERIC **)NULL);
                    /* we've added one more plot */
                }
            }
            return (OK);
        }

        if (mode == INT_NOIZ) {

            for ( ; model; model = model->SWnextModel) {

                for (inst = model->SWinstances; inst != NULL;
                        inst = inst->SWnextInstance) {

                    (void)sprintf(name,"onoise_total.%s",inst->SWname);

                    data->namelist = (IFuid *)
                        trealloc((char *)data->namelist,
                            (data->numPlots + 1)*sizeof(IFuid));

                    if (!data->namelist)
                        return (E_NOMEM);

                    (*(SPfrontEnd->IFnewUid))(ckt,
                        &(data->namelist[data->numPlots++]),
                        (IFuid)NULL,name,UID_OTHER,(GENERIC **)NULL);
                    /* we've added one more plot */

                    (void)sprintf(name,"inoise_total.%s",inst->SWname);
                    data->namelist = (IFuid *)
                        trealloc((char *)data->namelist,
                            (data->numPlots + 1)*sizeof(IFuid));

                    if (!data->namelist)
                        return (E_NOMEM);

                    (*(SPfrontEnd->IFnewUid))(ckt,
                        &(data->namelist[data->numPlots++]),
                        (IFuid)NULL,name,UID_OTHER,(GENERIC **)NULL);
                    /* we've added one more plot */
                }
            }
        }
        return (OK);
    }

    if (operation == N_CALC) {

        if (mode == N_DENS) {

            for ( ; model; model = model->SWnextModel) {

                for (inst = model->SWinstances; inst != NULL;
                        inst = inst->SWnextInstance) {

                    current_state = *(ckt->CKTstate0 + inst->SWstate);

                    NevalSrc(&noizDens,&lnNdens,ckt,THERMNOISE,
                        inst->SWposNode,inst->SWnegNode,
                        current_state ?
                        (model->SWonConduct):(model->SWoffConduct));

                    *OnDens += noizDens;

                    if (data->delFreq == 0.0) { 

                        /* if we haven't done any previous
                         * integration, we need to initialize our
                         * "history" variables
                         */

                        inst->SWnVar[LNLSTDENS] = lnNdens;

                        /* clear out our integration variable if
                         * it's the first pass
                         */

                        if (data->freq ==
                            ((NOISEAN*)ckt->CKTcurJob)->AC.fstart) {
                            inst->SWnVar[OUTNOIZ] = 0.0;
                        }
                    }
                    else {
                        /* data->delFreq != 0.0
                         * (we have to integrate)
                         */
                        tempOutNoise = Nintegrate(noizDens, lnNdens,
                            inst->SWnVar[LNLSTDENS], data);
                        tempInNoise = Nintegrate(noizDens * data->GainSqInv,
                            lnNdens + data->lnGainInv,
                            inst->SWnVar[LNLSTDENS] + data->lnGainInv,data);
                        inst->SWnVar[OUTNOIZ] += tempOutNoise;
                        inst->SWnVar[INNOIZ] += tempInNoise;
                        data->outNoiz += tempOutNoise;
                        data->inNoise += tempInNoise;
                        inst->SWnVar[LNLSTDENS] = lnNdens;
                    }
                    if (data->prtSummary) {
                        data->outpVector[data->outNumber++] = noizDens;
                    }
                }
            }
            return (OK);
        }

        if (mode == INT_NOIZ) {
            /* already calculated, just output */

            if (((NOISEAN*)ckt->CKTcurJob)->NStpsSm == 0)
                return (OK);

            for ( ; model; model = model->SWnextModel) {

                for (inst = model->SWinstances; inst != NULL;
                        inst = inst->SWnextInstance) {

                    data->outpVector[data->outNumber++] =
                        inst->SWnVar[OUTNOIZ];
                    data->outpVector[data->outNumber++] =
                        inst->SWnVar[INNOIZ];
                }
            }
        }
    }

    return (OK);
}

/***************************************************************************
JSPICE3 adaptation of Spice3f2 - Copyright (c) Stephen R. Whiteley 1992
Copyright 1990 Regents of the University of California.  All rights reserved.
Authors: 1987 Gary W. Ng
         1993 Stephen R. Whiteley
****************************************************************************/

#include "spice.h"
#include <stdio.h>
#include <math.h>
#include "resdefs.h"
#include "noisedef.h"
#include "fteconst.h"
#include "iferrmsg.h"
#include "util.h"

/*
 * RESnoise (mode, operation, firstModel, ckt, data, OnDens)
 *    This routine names and evaluates all of the noise sources
 *    associated with resistors.  It starts with the model *firstModel
 *    and traverses all of its instances.  It then proceeds to any other
 *    models on the linked list.  The total output noise density
 *    generated by all the resistors is summed in the variable "OnDens".
 */


int
RESnoise (mode, operation, genmodel, ckt, dataptr, OnDens)

int mode;
int operation;
GENmodel *genmodel;
CKTcircuit *ckt;
GENERIC *dataptr;
double *OnDens;
{
    Ndata *data = (Ndata*)dataptr;
    RESmodel *model = (RESmodel *) genmodel;
    RESinstance *inst;
    char name[N_MXVLNTH];
    double tempOutNoise;
    double tempInNoise;
    double noizDens;
    double lnNdens;
    int error;

    if (operation == N_OPEN) {

        /* see if we have to to produce a summary report
         * if so, name the noise generator
         */

        if (((NOISEAN*)ckt->CKTcurJob)->NStpsSm == 0)
            return (OK);

        if (mode == N_DENS) {

            for ( ; model; model = model->RESnextModel) {
                for (inst = model->RESinstances; inst;
                        inst = inst->RESnextInstance) {

                    (void)sprintf(name,"onoise.%s",inst->RESname);

                    data->namelist =
                        (IFuid *)trealloc((char *)data->namelist,
                        (data->numPlots + 1)*sizeof(IFuid));

                    if (!data->namelist)
                        return (E_NOMEM);

                    (*(SPfrontEnd->IFnewUid))(ckt,
                        &(data->namelist[data->numPlots++]),
                        (IFuid)NULL,name,UID_OTHER,(GENERIC **)NULL);
                        /* we've added one more plot */
                }
            }
            return (OK);
        }

        if (mode == INT_NOIZ) {

            for ( ; model; model = model->RESnextModel) {
                for (inst = model->RESinstances; inst;
                        inst = inst->RESnextInstance) {

                    (void)sprintf(name,"onoise_total.%s",inst->RESname);

                    data->namelist =
                        (IFuid *)trealloc((char *)data->namelist,
                        (data->numPlots + 1)*sizeof(IFuid));

                    if (!data->namelist)
                        return (E_NOMEM);

                    (*(SPfrontEnd->IFnewUid))(ckt,
                        &(data->namelist[data->numPlots++]),
                        (IFuid)NULL,name,UID_OTHER,(GENERIC **)NULL);
                    /* we've added one more plot */

                    (void)sprintf(name,"inoise_total.%s",inst->RESname);

                    data->namelist =
                        (IFuid *)trealloc((char *)data->namelist,
                        (data->numPlots + 1)*sizeof(IFuid));

                    if (!data->namelist)
                        return(E_NOMEM);

                    (*(SPfrontEnd->IFnewUid))(ckt,
                        &(data->namelist[data->numPlots++]),
                        (IFuid)NULL,name,UID_OTHER,(GENERIC **)NULL);
                    /* we've added one more plot */
                }
            }
        }
        return (OK);
    }

    if (operation == N_CALC) {

        if (mode == N_DENS) {

            for ( ; model; model = model->RESnextModel) {
                for (inst = model->RESinstances; inst;
                        inst = inst->RESnextInstance) {

                    NevalSrc(&noizDens,&lnNdens,ckt,THERMNOISE,
                        inst->RESposNode,inst->RESnegNode,inst->RESconduct);

                    *OnDens += noizDens;

                    if (data->delFreq == 0.0) { 

                        /* if we haven't done any previous integration,
                         * we need to initialize our "history" variables
                         */

                        inst->RESnVar[LNLSTDENS] = lnNdens;

                        /* clear out our integration variable if it's the
                         * first pass
                         */

                        if (data->freq ==
                            ((NOISEAN*)ckt->CKTcurJob)->AC.fstart) {
                            inst->RESnVar[OUTNOIZ] = 0.0;
                        }
                    }
                    else {
                        /* data->delFreq != 0.0 (we have to integrate) */
                        tempOutNoise = Nintegrate(noizDens, lnNdens,
                            inst->RESnVar[LNLSTDENS], data);
                        tempInNoise = Nintegrate(noizDens * 
                            data->GainSqInv ,lnNdens + data->lnGainInv,
                            inst->RESnVar[LNLSTDENS] + data->lnGainInv,
                            data);
                        inst->RESnVar[OUTNOIZ] += tempOutNoise;
                        inst->RESnVar[INNOIZ] += tempInNoise;
                        data->outNoiz += tempOutNoise;
                        data->inNoise += tempInNoise;
                        inst->RESnVar[LNLSTDENS] = lnNdens;
                    }
                    if (data->prtSummary) {
                        data->outpVector[data->outNumber++] = noizDens;
                    }
                }
            }
            return (OK);
        }

        if (mode == INT_NOIZ) {

            if (((NOISEAN*)ckt->CKTcurJob)->NStpsSm == 0)
                return (OK);

            for ( ; model; model = model->RESnextModel) {
                for (inst = model->RESinstances; inst;
                        inst = inst->RESnextInstance) {

                    /* already calculated, just output */
                    data->outpVector[data->outNumber++] =
                        inst->RESnVar[OUTNOIZ];
                    data->outpVector[data->outNumber++] =
                        inst->RESnVar[INNOIZ];
                }
            }
        }
    }
    return (OK);
}
            

